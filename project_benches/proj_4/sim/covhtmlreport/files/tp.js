var g_data = {"tp":[{"fixed_attr_val":[415,217,89.33,89.33,"testplan",1,"testplan","-",0,"0",1],"children":[{"fixed_attr_val":[266,77,53.61,53.61,"testplan",1,"Registers",100.00,1,"1",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Reset Values",100.00,2,"1.1",1],"usr_attr":[{"Description":"After a reset, registers should hold the values defined throughout Section 5 of the I2CMB specification."}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","reg_reset_test","-"]}]},{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Access Permissions",100.00,2,"1.2",1],"usr_attr":[{"Description":"Verify that the access permissions described throughout Section 5 of the I2CMB specification are enforced."}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","reg_access_test","-"]}]},{"fixed_attr_val":[8,7,87.50,87.50,"testplan",1,"All Registers Written to and Read from",100.00,2,"1.3",1],"usr_attr":[{"Description":"Ensure that all I2CMB registers have been written to and read from"}],"children":[{"fixed_attr_val":[8,7,87.50,87.50,"cross",1,"/wb_pkg/wb_monitor/wb_monitor_cg/reg_x_op",100.00]}]},{"fixed_attr_val":[256,69,26.95,26.95,"testplan",1,"Ensure that Every Register has been Written with All Data",100.00,2,"1.4",1],"usr_attr":[{"Description":"Ensure that all possible data values have been written to WB Registers"}],"children":[{"fixed_attr_val":[256,69,26.95,26.95,"cross",1,"/wb_pkg/wb_monitor/wb_monitor_cg/reg_x_data",100.00]}]}]},{"fixed_attr_val":[2,2,100.00,100.00,"testplan",1,"IRQ",100.00,1,"2",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"IRQ Low When Disabled",100.00,2,"2.1",1],"usr_attr":[{"Description":"If the Interrupt Enable (IE) bit of the CSR register is unset, IRQ should never be high."}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_agent/bl_create_put/assert_irq_low_if_disabled",100.00]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"IRQ Valid",100.00,2,"2.2",1],"usr_attr":[{"Description":"IRQ should only be set when predicted."}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_agent/bl_create_put/assert_irq_predicted",100.00]}]}]},{"fixed_attr_val":[11,9,93.75,93.75,"testplan",1,"Byte Level Commands",100.00,1,"3",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[8,6,75.00,75.00,"testplan",1,"All Commands Used",100.00,2,"3.1",1],"usr_attr":[{"Description":"All I2CMB commands should be used at least once"}],"children":[{"fixed_attr_val":[8,6,75.00,75.00,"coverpoint",1,"/wb_pkg/wb_monitor/wb_monitor_cg/cmd_ran",100.00]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Wait Command Test",100.00,2,"3.2",1],"usr_attr":[{"Description":"Verify that the Wait command waits the specified amount"}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","wait_test","-"]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Valid Responses",100.00,2,"3.3",1],"usr_attr":[{"Description":"Verify that byte level commands only return responses consistenct with Table 3 of Section 3.1 of the I2CMB specification."}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_agent/bl_create_put/assert_valid_response",100.00]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Correct Responses",100.00,2,"3.4",1],"usr_attr":[{"Description":"Verify that predicted responses match monitored responses"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_agent/bl_create_put/assert_correct_response",100.00]}]}]},{"fixed_attr_val":[132,125,98.90,98.90,"testplan",1,"I2C Functionality",100.00,1,"4",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Read Test",100.00,2,"4.1",1],"usr_attr":[{"Description":"The DUT should be able to send read commands to I2C slaves"}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","i2c_read_test","-"]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Write Test",100.00,2,"4.2",1],"usr_attr":[{"Description":"The DUT should be able to send write commands to I2C slaves"}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","i2c_write_test","-"]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Random Test",100.00,2,"4.3",1],"usr_attr":[{"Description":"The DUT should be able to pass a test that uses Random Transactions"}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","i2c_random_test","-"]}]},{"fixed_attr_val":[128,121,94.53,94.53,"testplan",1,"All Addresses Written to and Read from",100.00,2,"4.4",1],"usr_attr":[{"Description":"Ensure that all addresses have been written to and read from"}],"children":[{"fixed_attr_val":[128,121,94.53,94.53,"cross",1,"/i2c_pkg/i2c_monitor/i2c_monitor_cg/op_x_addr",100.00]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Correct Transactions",100.00,2,"4.5",1],"usr_attr":[{"Description":"Ensure that I2C transactions match what were predicted"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/i2cmb_env_pkg/i2cmb_scoreboard/nb_put/assert_correct_i2c_trans",100.00]}]}]},{"fixed_attr_val":[4,4,100.00,100.00,"testplan",1,"Advanced I2C Capabilities",100.00,1,"5",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Repeated Start Test",100.00,2,"5.1",1],"usr_attr":[{"Description":"The DUT should be able to transmit another command on an already captured I2C bus using a repeated start command instead of a stop command"}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","i2c_rep_start_test","-"]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Multi-Master Clock Synchronization",100.00,2,"5.2",1],"usr_attr":[{"Description":"As described in section 3.1.7 of the I2C specification. Whenever SCL faces a high to low transition (such as if another master is driving the clock) the DUT should start counting off its LOW period from that instance on."}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","clock_sync_test","-"]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Multi-Master Arbitration",100.00,2,"5.3",1],"usr_attr":[{"Description":"As described in section 3.1.8 of the I2C specification. The master should lose arbitration if it tries to send a HIGH but detects a LOW."}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","arbitration_test","-"]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Clock Stretching",100.00,2,"5.4",1],"usr_attr":[{"Description":"As described in section 3.1.9 of the I2C specification, slaves should be able to hold the clock low to force the master to wait."}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","clock_stretch_test","-"]}]}]},{"fixed_attr_val":[0,0,89.73,89.73,"testplan",1,"Code Coverage",100.00,1,"6",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[0,0,89.73,89.73,"testplan",1,"DUT",100.00,2,"6.1",1],"usr_attr":[{"Description":"Ensure that all design units have 100% statement code coverage"}],"children":[{"fixed_attr_val":[0,0,89.73,89.73,"instance",1,"/top/DUT",100.00]}]}]}]}],"head":["Description"]};
processTpLinks(g_data);